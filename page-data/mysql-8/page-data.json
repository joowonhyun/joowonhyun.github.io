{"componentChunkName":"component---src-pages-contentful-post-slug-tsx","path":"/mysql-8/","result":{"data":{"contentfulPost":{"title":"[MySQL] 성능 최적화를 위해 고려해야할 8가지","category":["mysql"],"date":"2024-08-06","slug":"mysql-8","thumbnail":{"url":"https://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png?w=250&h=250&q=50&fm=webp 250w,\nhttps://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png?w=500&h=500&q=50&fm=webp 500w,\nhttps://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png?w=1000&h=1000&q=50&fm=webp 1000w,\nhttps://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png?w=2000&h=2000&q=50&fm=webp 2000w","sizes":"(min-width: 1000px) 1000px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png?w=1000&h=1000&q=50&fm=png","srcSet":"https://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png?w=250&h=250&q=50&fm=png 250w,\nhttps://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png?w=500&h=500&q=50&fm=png 500w,\nhttps://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png?w=1000&h=1000&q=50&fm=png 1000w,\nhttps://images.ctfassets.net/v8jcs71vfccu/2Sspb8ost7qNNOnupguJ0J/47bb6d38e01380f98f32d7e0ed60e9b2/mysql-logo.png?w=2000&h=2000&q=50&fm=png 2000w","sizes":"(min-width: 1000px) 1000px, 100vw"}},"layout":"constrained","backgroundColor":"#080808","width":1000,"height":1000}},"description":{"description":"MySQL에서 최적화를 위해 무엇을 고려해야 할까?"},"content":{"raw":"{\"nodeType\":\"document\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"최근 mysql 최적화에 관심이 생겨서 인프런 강의를 수강하고 있다.\\n최적화의 기본은 데이터 엑세스를 줄이고 이를 위해선 인덱스를 활용하는 방식이 가장 기본일 것이다.\\n강의를 들으며 인덱스와 인덱스를 활용한 성능 최적화에 대해 배운 점 8가지를 정리해보고자 한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"\",\"marks\":[],\"data\":{}},{\"nodeType\":\"hyperlink\",\"data\":{\"uri\":\"https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-mysql-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%95%ED%99%95-sql%ED%8A%9C%EB%8B%9D\"},\"content\":[{\"nodeType\":\"text\",\"value\":\"비전공자도 이해할 수 있는 MySQL 성능 최적화 입문/실전 (SQL 튜닝편)\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"text\",\"value\":\"\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"#인덱스란?\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"underline\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"데이터를 빨리 찾기 위해 \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"\\\"특정 컬럼\\\"\",\"marks\":[{\"type\":\"underline\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"을 기준으로 정리해놓은 표이다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"그렇다면 특정 컬럼은 무엇을 기준으로 고려해서 인덱스를 설정하면 성능이 향상 될 (확률)이 높아질까? 인덱스 컬럼을 활용할 때 하면 안되는 것은 뭘까? 총 8가지 항목을 살펴보겠다.\\n물론 이게 끝이 아니고, 실행 계획을 꼭 확인해봐야 한다는 점을 잊으면 안된다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"#1. WHERE에 사용되는 컬럼에 인덱스 설정해보자.\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"underline\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"WHERE문의 (부등호, IN, BETWEEN, LIKE) 와 같은 곳에서 사용되는 컬럼에 인덱스를 설정하면 성능이 향상될 가능성이 높다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"#2. 중복 정도가 낮은 컬럼에 인덱스를 설정하자.\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"underline\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"\\b데이터 엑세스를 크게 줄일 수 있는 컬럼은 중복 정도가 낮은 컬럼이다. 중복 정도가 낮은 컬럼을 골라서 인덱스를 생성해보자\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"#3. 인덱스 컬럼을 가공하지 말자.\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"underline\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"\\b인덱스가 설정된 컬럼을 가공(함수 적용, 문자열 조작 등)하면 MySQL은 해당 인덱스를 활용하지 못하는 경우가 있다. 인덱스를 적극 활용하기 위해서는 인덱스 컬럼 자체를 최대한 가공하지 않아야 한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"#4. ORDER BY는 시간이 오래 걸리는 작업이다.\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"underline\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"제목 그대로 order by는 시간이 오래 걸리는 작업이므로 최대한 피해주는 것이 좋다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"#5. 조회 데이터의 범위를 줄이자.\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"underline\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"LIMIT 없이 큰 범위의 데이터를 조회해오는 경우 옵티마이저가 인덱스를 활용하지 않고 Full Table Scan을 할 수도 있다. 따라서 성능 효율을 위해 LIMIT을 통해 작은 데이터의 범위를 조회해오도록 신경쓰자\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"#6. 인덱스는 ORDER BY 보다 WHERE\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"underline\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"ORDER BY의 특징 상 모든 데이터를 바탕으로 정렬을 해야 하기 때문에, 인덱스 풀스캔 또는 테이블 풀스캔을 활용할 수 밖에 없다. 이 때문에 ORDER BY문보다 WHERE문에 있는 컬럼에 인덱스를 걸었을 때 성능이 향상되는 경우가 많다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"#7. HAVING 대신 WHERE를 쓸 수 있나 확인해보자\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"underline\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"HAVING이 오려면 GROUP BY를 먼저 수행해야 한다. 그 전에 WHERE을 통해 먼저 조건을 필터링 하면 성능을 개선할 수 있다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"#8. 멀티 컬럼 인덱스의 순서는 중요하다.\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"underline\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"여러 컬럼을 묶어서 인덱스로 설정할 수도 있다. 이때 컬럼의 순서는 매우 중요하다. \\n멀티 컬럼 인덱스를 설정했을 때 탐색하는 방식은 \\\"\",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"배치한 컬럼의 순서대로 탐색\\\"\",\"marks\":[{\"type\":\"underline\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"하기 때문이다.\\n예를 들어 (부서, 이름)의 순서대로 멀티 컬럼 인덱스를 구성했다면 먼저 일치하는 부서를 찾은 뒤, 일치하는 부서에서 이름을 찾는 식으로 처리한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"따라서 멀티 컬럼 인덱스를 구성할 때는 \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"데이터 중복도가 높은 컬럼이 앞쪽으로 오는 게 좋은 경우가 많다.\",\"marks\":[{\"type\":\"bold\"},{\"type\":\"italic\"},{\"type\":\"underline\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" 데이터 중복도가 높은 컬럼일수록 큼지막하게 분류가 되어 있다는 뜻이기도 하다.\",\"marks\":[],\"data\":{}}]}]}","references":[]}}},"pageContext":{"id":"51e2caa5-67fb-5096-beb7-1948e368ce19","slug":"mysql-8","__params":{"slug":"mysql-8"}}},"staticQueryHashes":["506648845"],"slicesMap":{}}